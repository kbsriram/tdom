<!doctype html>
<html lang="en">
<head>
<title>TDom: A succinct way to manipulate dom-like structures</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<link rel="stylesheet" href="css/style.css"/>
</head>
<body>
<h1>TDom</h1>

<p>For some time now I've been using a technique to succinctly create
and manipulate DOM-like trees from Java. It is useful to generate HTML
or XML without using JSPs or pulling in large libraries.</p>

<p>The code is in
<a href="https://github.com/kbsriram/tdom/blob/master/src/core/org/tdom/TDom.java">a
single java file</a> running around 600 lines. You can directly
add it to your source, or grab
<a href="https://github.com/kbsriram/tdom/raw/master/bin/tdom.jar">a jar
file</a> from the
<a href="https://github.com/kbsriram/tdom/">github repository</a>.  At
any rate, I hope you find the code small enough to be adapted for your
own needs.</p>

<h2>Usage</h2>

<p>Constructing HTML declaratively works with a set of static methods,
and is indented directly by your editor.  The resulting indentation
reflects the structure of the HTML. The method names are
inconspicuous, and the HTML is visually prominent as you scan the
code.</p>

<pre>
import org.tdom.TDom;
import static org.tdom.TDom.*;

// ....
// Create straight-up html 
TNode html =
    n("html",
      n("head",
        n("title", t("A title"))),
      n("body",
        n("div", a("class", "content"),
          t("Hello, world."))));
</pre>

<p><tt>n()</tt> creates nodes, <tt>a()</tt> adds attributes, and
<tt>t()</tt> creates text. These methods can be nested
arbitrarily, and mirrors the structure of the underlying HTML.</p>

<p>However, you'll probably construct large structures in separate
methods rather than directly inline as above.</p>

<pre>
TNode html =
    n("html",
      makeHead(headerData),
      makeBody(bodyData));
</pre>

<p>This permits a more modular way to construct the tree, please see
the section on <a href="#patterns">Typical Patterns</a> as well. But
I'll stick to the declarative style in this example.</p>

<p>Once you have a partially constructed tree, you can continue
inserting nodes. I've borrowed something like jQuery's selector
mechanism for this.</p>

<pre>
// &lt;body&gt;
// &lt;div class="content"&gt;
// ...

// Insert a title before the content div
html.before(".content", n("h1", t("The Title")));

// Becomes:
// &lt;body&gt;
// &lt;h1&gt;The Title&lt;/h1&gt;
// &lt;div class="content"&gt;
// ...
</pre>

<p>The selector syntax is limited. You can use tagged classes and
ids (eg: <tt>"div.content"</tt>, <tt>"span#id"</tt>, <tt>"body"</tt>,
<tt>"#otherid"</tt> etc.)</p>

<p>You can also use simple attribute-based selectors.
<tt>"div[itemprop='affiliation']"</tt> selects all <tt>div</tt>s
that contain an attribute <tt>itemprop</tt> with the
value <tt>affiliation</tt>. <tt>"a[name]"</tt> selects all <tt>a</tt>
elements that have a <tt>name</tt> attribute, regardless of its value,
and <tt>"[itemprop]"</tt> matches any element that has
an <tt>itemprop</tt> attribute. <tt>"div.content"</tt> is equivalent
to <tt>"div[class=~'content']"</tt>. The <tt>~</tt> character indicates
that <tt>content</tt> can be one of the (whitespace separated) values in
the <tt>class</tt> attribute. Note that the
single quote (<tt>'</tt>) is used in the attribute selectors to avoid
backslashitis in java.</p>

<p>Finally, descendant selectors can be used, (eg:
<tt>"div.content a[href]"</tt> selects all <tt>a</tt> tags that have
an <tt>href</tt> attribute, but only if they occur within
a <tt>div.content</tt> block.)</p>

<p>Selectors simplify inserting new nodes relative to other nodes, or
performing a bulk change on a partially created tree.  Operations on
selectors are always performed on all the selected nodes. Also note
that methods can be chained.</p>

<pre>

// html.before(".content", ...) internally runs
// html.select(".content").before(...)

html.select(".content").dump(printWriter);
// &lt;div class="content"&gt;Hello, world.&lt;/div&gt;

// Append a content block to the end of the body.
html.append("body",
            n("div", a("class", "content"),
              t("Goodbye, World")));

html.select(".content").dump(printWriter);
// This now selects two nodes.
// &lt;div class="content"&gt;Hello, world.&lt;/div&gt;
// &lt;div class="content"&gt;Goodbye, World&lt;/div&gt;

</pre>

<p>If you like the chaining style, you can perform several operations
in one shot.</p>

<pre>

// Add a spacing ruler at the end of all content blocks, a
// css file to the header, and render the result.
html
  .after(".content", n("hr", a("class", "space")))

  .append("head",
            n("link", a("rel", "stylesheet"),
                      a("href", "css/style.css")))
  .dump(printWriter);
</pre>

The generated HTML <a href="example.html">looks like this</a>, and you
can look at the <a href="https://github.com/kbsriram/tdom/blob/master/src/example/Example.java">full source</a> for this example.

<h2><a class="quiet" name="patterns">Typical Patterns</a></h2>

<p>Visual design is often done through CSS files, leaving the Java
code to generate relatively straightforward <tt>div</tt>
structures.</p>

<p>Java design patterns also normally have a layer that generates a data
object composed of many smaller data objects, and a rendering layer
that generates HTML from these objects. For instance, to render a
picture album, there may be a <tt>AlbumInfo</tt> object that contains
a list of <tt>PictureInfo</tt> objects, as well as some meta-data
about the album itself.</p>

<p>One way to render such objects is by creating different methods (or
classes, if you prefer) that create a sub-tree for each interesting
sub-object. The parent method then composes sub-trees generated by the
child methods into a larger tree, and so on.</p>

<p>So there could be a <tt>makePictureTile(PictureInfo)</tt> method
that creates the tree for one tile. A <tt>makeAlbum(AlbumInfo)</tt>
method would call <tt>makePictureTile()</tt> for
each <tt>PictureInfo</tt> object and compose it into a larger tree for
the album, and so on. The outer code just passes the container object
to an appropriate top-level method, and renders the resultant tree
after any desired tweaks.</p>

<p>Note that the library provides no support to format text (say
dates.)  I've found it simplest to use dedicated, locale-specific
libraries for this purpose (eg: java.text.MessageFormat, or some other
translation library.)</p>

<p>Lastly, as this is a data-structure rather than markup, you can
render the structure into different textual formats. This makes it
possible to have a servlet generate machine-readable formats (say XML
or JSON) as well as HTML, depending on the URL or other parameters in
the request.</p>

<p>Here is <a href="https://github.com/kbsriram/tdom/blob/master/src/example/RenderingExample.java">an example</a>
that demonstrates how you can
generate both HTML and a <a href="http://tools.ietf.org/html/rfc6350">vCard</a> file from the same
data structure.</p>

<pre>

// create content for a user profile page marked up with hCard tags.
// [a common Google indexing tweak.]

TNode html = ....;

html.dump(printWriter);
//
// &lt;html&gt;
// ...
// &lt;h1&gt;This is the info for a user&lt;/h1&gt;
// &lt;div class="vcard"&gt;
//   &lt;img class="photo" src="http://example.com/bob.jpg" /&gt;
//   &lt;strong class="fn"&gt;Bob Smith&lt;/strong&gt; is the
//    &lt;span class="title"&gt;Senior editor&lt;/span&gt; at 
//    &lt;span class="org"&gt;ACME Reviews&lt;/span&gt;
// &lt;/div&gt;
// &lt;h3&gt;This is a footer&lt;/h3&gt;
// ...

// Select vcard tags and dump them out.
html.select(".vcard").visit(new VCardRenderer(printWriter));

// BEGIN:VCARD
// VERSION:4.0
// PHOTO:http://example.com/bob.jpg
// FN:Bob Smith
// TITLE:Senior editor
// ORG:ACME Reviews
// END:VCARD

</pre>

<p style="margin-top:2.75em; margin-left:-8%;text-align:right"><small>by <a href="https://plus.google.com/102207019656909757485?rel=author">KB Sriram <img src="https://lh5.googleusercontent.com/-9fHCOzZy0WI/AAAAAAAAAAI/AAAAAAAAAIk/fH4Ta6jcviI/s48-c-k/photo.jpg" style="height:3.4375em; float: right;margin-top:-2.175em; margin-left: 0.4em;"/> </a></small></p>
</body>
</html>
